#define MAXNAMELENGTH 15#include <stdio.h>#include <stdlib.h>#include <string.h>/* * First Name: Carl * Last Name: El Khoury * Student ID:260806273 *///Define structure to hold student datastruct StudentRecord{    char FirstNames[MAXNAMELENGTH];    char LastNames[MAXNAMELENGTH];    int IDNums;    int Marks;};struct branch // creating a branch struct that is a binary branch in our tree{    struct StudentRecord* current; // it points to a student record which is the values stored in the current branch    struct branch* left;//it points to a left and right branch(if there is one)    struct branch* right;};void printtree(struct branch* root) {// a printtree function that isn't used in the program but was used for debugging and testing the binomial tree    if (root == NULL)// checks if the current branch is NULL if yes it ends the program.        return;    if (root->left != NULL) // check if the left branch exists if yes printtree of left        printtree(root->left);    printf("Last name: %s\n", root->current->LastNames); // after we printtree the left side of the tree we printf the value of the current branch    if (root->right != NULL) //after we printtree the left and the current value we travers the right tree and repeate everything again        printtree(root->right);}struct StudentRecord* Search_tree (struct branch* root, char* argv){ // we search the value of the binary tree after we have sorted it    if (strcasecmp(root->current->LastNames, argv)==0){ // check if the current branch matches our target (argv) if yes just return its value to compare strings we use the strcasecmp that is case insensitive        return root->current;    }    if (strcasecmp(root->current->LastNames, argv)>0){ // if not, check if current branch is of higher alphatic order if yes go left (if there is one) if not go right (if there is one) and repeat the search_tree        if (root->left != 0){ //checking if there is a root if yes go left            Search_tree(root->left,argv);        }        else {            printf("No record found for student with last name %s.",argv);//if no then the name we are searching for isn't in the list            return 0;        }    }    else if (root->right != 0) { // check if there is a right        Search_tree(root->right, argv); //if yes search the right part    }    else {        printf("No record found for student with last name %s.",argv); //if no the name that we are searching for isn't in the list        return 0;    }};void addnode (struct branch** root,struct StudentRecord* SRecords) { //adding a pointer to a student record to the binary tree by sending the root to the function, the pointer itself.    if (*root == 0) { // check if the current branch is null if yes allocate space and put the value of SRecords in it and give the value null to the left and the right branches        (*root) = (struct branch*)(malloc(sizeof(struct branch)));        (*root)->left = 0;        (*root)->right = 0;        (*root)->current = SRecords;        return;    }    if(root != NULL){ // if the branch isn't empty check the last name stored in it        if (strcmp(((*root)->current->LastNames), ((SRecords)->LastNames)) > 0) { // if the last name is of higher alphabetic order then the Lastname of the student record we are adding go left            addnode(&(*root)->left, SRecords); // run the function again for the left root        }else{//if not go right            addnode(&(*root)->right, SRecords); // run the function again for the right root        }}}int main(int argc, char * argv[]) {    //Read in Names and ID data    FILE * NamesIDs;    FILE * marks;    if((NamesIDs = fopen(argv[1], "r")) == NULL){        printf("Can't read from file %s\n", argv[1]);        exit(1);    }    if((marks = fopen(argv[2], "r")) == NULL){        printf("Can't read from file %s\n", argv[2]);        exit(1);    }    if (argc!=4){        printf("wrong number of arguments");        return 0;    }    struct branch *root = 0; //initializing the binary tree        while (1) {            struct StudentRecord *p = malloc(sizeof(struct StudentRecord));//creating a student records to store the next value of NamesIDs and marks            if (fscanf(NamesIDs, "%s%s%d", &(p->FirstNames), &(p->LastNames), &(p->IDNums)) != EOF && (fscanf(marks, "%d", &(p->Marks)) != EOF)) { //reading the values of the file, when there are no more values break the while loop                addnode(&root, p); //adding each structure to the binary tree            }            else                break;        }    fclose(NamesIDs);    fclose(marks);   //printtree(root); //implemented for testing perposes    struct StudentRecord* result = (Search_tree(root,argv[3])); // search the binary tree by passing a pointer to the first branch and the targeted last name(argv[3]) and this returns the pointer to the result (if there is one)    if (result==0) // check if we have an answer if not terminate        return 0;    printf("The following record was found:\nLastName: %s\nFirstname: %s\nStudent ID: %d\nMark: %d",result->LastNames,result->FirstNames,result->IDNums,result->Marks); //print the data of the student we found.    return EXIT_SUCCESS;}